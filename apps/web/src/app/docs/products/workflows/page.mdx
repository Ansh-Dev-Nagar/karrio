---
sidebarTitle: Workflows
title: Integration Workflows
description: Build automated shipping workflows using Karrio's webhook system and REST APIs
tags: ["webhooks", "automation", "integration", "workflows", "rest-api"]
---

# Integration Workflows

Build automated shipping workflows by combining Karrio's webhook system with your application logic. Create event-driven processes that respond to shipping events and automate common shipping tasks through the REST API.

## Overview

While Karrio doesn't include a built-in workflow engine, you can create sophisticated automation by combining webhooks, REST API calls, and your application logic. This approach provides maximum flexibility for implementing business-specific shipping processes.

### Key Capabilities

- **Webhook-Driven Events**: React to shipping events in real-time
- **REST API Integration**: Automate shipping operations through API calls
- **Custom Business Logic**: Implement your specific business rules and processes
- **Event-Driven Architecture**: Build responsive, scalable shipping automation

## Common Integration Patterns

### Order-to-Shipment Automation

Automatically create shipments when orders are received:

```javascript
// Webhook handler for order creation
app.post("/webhooks/orders", async (req, res) => {
  const { type, data } = req.body;

  if (type === "order_created") {
    try {
      // Create shipment from order data
      const shipment = await createShipmentFromOrder(data);
      console.log(`Shipment created: ${shipment.id}`);

      // Update order with shipment info
      await updateOrderStatus(data.id, {
        status: "processing",
        shipment_id: shipment.id,
      });
    } catch (error) {
      console.error("Shipment creation failed:", error);
      // Handle error - notify staff, retry later, etc.
    }
  }

  res.status(200).send("OK");
});

async function createShipmentFromOrder(order) {
  const response = await fetch("https://api.karrio.io/v1/shipments", {
    method: "POST",
    headers: {
      Authorization: "Token YOUR_API_KEY",
      "Content-Type": "application/json",
    },
    body: JSON.stringify({
      shipper: order.shipping_from,
      recipient: order.customer,
      parcels: mapOrderItemsToParcels(order.line_items),
      service: selectShippingService(order),
      reference: order.order_id,
      metadata: {
        order_id: order.id,
        customer_id: order.customer_id,
      },
    }),
  });

  return await response.json();
}
```

### Tracking Update Notifications

Automatically notify customers of delivery updates:

```javascript
// Webhook handler for tracking updates
app.post("/webhooks/tracking", async (req, res) => {
  const { type, data } = req.body;

  if (type === "tracker.updated") {
    // Send customer notification based on status
    switch (data.status) {
      case "shipped":
        await sendShippedNotification(data);
        break;
      case "out_for_delivery":
        await sendOutForDeliveryNotification(data);
        break;
      case "delivered":
        await sendDeliveredNotification(data);
        break;
      case "delivery_failed":
        await handleDeliveryException(data);
        break;
    }
  }

  res.status(200).send("OK");
});

async function sendShippedNotification(tracker) {
  // Get order info from metadata
  const order = await getOrderById(tracker.metadata?.order_id);

  if (order?.customer?.email) {
    await sendEmail({
      to: order.customer.email,
      subject: `Your order ${order.order_id} has shipped!`,
      template: "shipped",
      data: {
        tracking_number: tracker.tracking_number,
        carrier_name: tracker.carrier_name,
        estimated_delivery: tracker.estimated_delivery,
      },
    });
  }
}
```

### Exception Handling Workflow

Handle delivery exceptions automatically:

```javascript
async function handleDeliveryException(tracker) {
  const order = await getOrderById(tracker.metadata?.order_id);

  // Log the exception
  console.log(
    `Delivery exception for ${tracker.tracking_number}:`,
    tracker.events[0]?.description,
  );

  // Determine action based on exception type
  const lastEvent = tracker.events[0];

  if (lastEvent?.description?.includes("address")) {
    // Address issue - contact customer
    await requestAddressCorrection(order, tracker);
  } else if (lastEvent?.description?.includes("unavailable")) {
    // Customer unavailable - schedule redelivery
    await scheduleRedelivery(tracker);
  } else {
    // Other exception - alert customer service
    await alertCustomerService(order, tracker);
  }
}

async function requestAddressCorrection(order, tracker) {
  await sendEmail({
    to: order.customer.email,
    subject: "Address Correction Needed",
    template: "address_correction",
    data: {
      order_id: order.order_id,
      tracking_number: tracker.tracking_number,
    },
  });
}
```

### Batch Processing Workflow

Process multiple shipments efficiently:

```javascript
// Process daily batch of orders
async function processDailyOrders() {
  try {
    // Get pending orders
    const orders = await getPendingOrders();
    console.log(`Processing ${orders.length} orders`);

    // Group orders by shipping method for batch processing
    const batches = groupOrdersByShippingMethod(orders);

    for (const [method, orderBatch] of Object.entries(batches)) {
      await processBatch(method, orderBatch);
    }
  } catch (error) {
    console.error("Batch processing failed:", error);
  }
}

async function processBatch(method, orders) {
  // Create shipments for batch
  const shipmentRequests = orders.map((order) => ({
    shipper: getWarehouseAddress(),
    recipient: order.customer,
    parcels: mapOrderItemsToParcels(order.line_items),
    service: method,
    reference: order.order_id,
    metadata: { order_id: order.id },
  }));

  // Process in chunks to avoid rate limits
  const chunks = chunkArray(shipmentRequests, 10);

  for (const chunk of chunks) {
    const promises = chunk.map((request) =>
      createShipment(request).catch((error) => ({ error, request })),
    );

    const results = await Promise.all(promises);

    // Handle results
    results.forEach((result, index) => {
      if (result.error) {
        console.error(
          `Shipment failed for order ${chunk[index].reference}:`,
          result.error,
        );
      } else {
        console.log(`Shipment created: ${result.id}`);
      }
    });
  }
}
```

## Event-Driven Architecture

### Webhook Event Processing

```javascript
// Centralized webhook processor
class WebhookProcessor {
  constructor() {
    this.handlers = new Map();
    this.setupHandlers();
  }

  setupHandlers() {
    // Order events
    this.handlers.set("order_created", this.handleOrderCreated);
    this.handlers.set("order_updated", this.handleOrderUpdated);
    this.handlers.set("order_cancelled", this.handleOrderCancelled);

    // Shipment events
    this.handlers.set("shipment_created", this.handleShipmentCreated);
    this.handlers.set("shipment_purchased", this.handleShipmentPurchased);
    this.handlers.set("shipment_cancelled", this.handleShipmentCancelled);

    // Tracking events
    this.handlers.set("tracker.created", this.handleTrackerCreated);
    this.handlers.set("tracker.updated", this.handleTrackerUpdated);
  }

  async process(event) {
    const handler = this.handlers.get(event.type);

    if (handler) {
      try {
        await handler.call(this, event.data);
      } catch (error) {
        console.error(`Error processing ${event.type}:`, error);
        throw error;
      }
    } else {
      console.log(`No handler for event type: ${event.type}`);
    }
  }

  async handleOrderCreated(data) {
    console.log(`Processing new order: ${data.order_id}`);
    // Implement your order processing logic
  }

  async handleTrackerUpdated(data) {
    console.log(`Tracking update: ${data.tracking_number} - ${data.status}`);
    // Implement your tracking update logic
  }
}

// Usage in Express app
const processor = new WebhookProcessor();

app.post("/webhooks/:type", async (req, res) => {
  try {
    await processor.process(req.body);
    res.status(200).send("OK");
  } catch (error) {
    console.error("Webhook processing error:", error);
    res.status(500).send("Error");
  }
});
```

### Background Job Processing

Implement reliable background processing for time-intensive tasks:

```javascript
// Using a job queue (e.g., Bull, Agenda, etc.)
const Queue = require("bull");
const shipmentQueue = new Queue("shipment processing");

// Add job to queue from webhook
app.post("/webhooks/orders", async (req, res) => {
  if (req.body.type === "order_created") {
    // Add to background queue instead of processing immediately
    await shipmentQueue.add("create_shipment", req.body.data, {
      attempts: 3,
      backoff: "exponential",
      delay: 1000,
    });
  }
  res.status(200).send("Queued");
});

// Process jobs in background
shipmentQueue.process("create_shipment", async (job) => {
  const order = job.data;

  try {
    const shipment = await createShipmentFromOrder(order);

    // Update order status
    await updateOrderStatus(order.id, {
      status: "shipped",
      shipment_id: shipment.id,
      tracking_number: shipment.tracking_number,
    });

    return { success: true, shipment_id: shipment.id };
  } catch (error) {
    console.error("Shipment creation failed:", error);
    throw error; // Job will be retried
  }
});
```

## Integration Examples

### E-commerce Platform Integration

```javascript
// Complete e-commerce automation workflow
class EcommerceWorkflow {
  async handleNewOrder(order) {
    try {
      // 1. Validate order
      await this.validateOrder(order);

      // 2. Check inventory
      const inventoryCheck = await this.checkInventory(order.line_items);
      if (!inventoryCheck.available) {
        await this.handleBackorder(order);
        return;
      }

      // 3. Create shipment
      const shipment = await this.createShipment(order);

      // 4. Purchase label
      const label = await this.purchaseLabel(shipment);

      // 5. Update order
      await this.updateOrder(order.id, {
        status: "shipped",
        tracking_number: shipment.tracking_number,
        shipment_id: shipment.id,
      });

      // 6. Send notifications
      await this.sendShippingNotification(order, shipment);
    } catch (error) {
      await this.handleError(order, error);
    }
  }

  async createShipment(order) {
    const response = await fetch("https://api.karrio.io/v1/shipments", {
      method: "POST",
      headers: {
        Authorization: "Token YOUR_API_KEY",
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        shipper: this.getWarehouseAddress(),
        recipient: order.shipping_address,
        parcels: this.mapOrderToParcels(order),
        service: this.selectShippingService(order),
        reference: order.order_id,
      }),
    });

    if (!response.ok) {
      throw new Error(`Shipment creation failed: ${response.statusText}`);
    }

    return await response.json();
  }
}
```

### Multi-Carrier Failover

```javascript
// Implement carrier failover logic
async function createShipmentWithFailover(shipmentData) {
  const carriers = ["fedex", "ups", "usps"]; // Priority order

  for (const carrier of carriers) {
    try {
      const response = await fetch("https://api.karrio.io/v1/shipments", {
        method: "POST",
        headers: {
          Authorization: "Token YOUR_API_KEY",
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          ...shipmentData,
          carrier_ids: [carrier], // Try specific carrier
        }),
      });

      if (response.ok) {
        const shipment = await response.json();
        console.log(`Shipment created with ${carrier}:`, shipment.id);
        return shipment;
      }

      console.warn(`Carrier ${carrier} failed, trying next...`);
    } catch (error) {
      console.error(`Carrier ${carrier} error:`, error);
    }
  }

  throw new Error("All carriers failed");
}
```

## Best Practices

### Error Handling and Resilience

```javascript
// Implement retry logic with exponential backoff
async function withRetry(operation, maxAttempts = 3) {
  for (let attempt = 1; attempt <= maxAttempts; attempt++) {
    try {
      return await operation();
    } catch (error) {
      if (attempt === maxAttempts) {
        throw error;
      }

      const delay = Math.pow(2, attempt) * 1000; // Exponential backoff
      console.log(`Attempt ${attempt} failed, retrying in ${delay}ms...`);
      await new Promise((resolve) => setTimeout(resolve, delay));
    }
  }
}

// Usage
const shipment = await withRetry(() => createShipment(orderData));
```

### Idempotency

```javascript
// Ensure operations are idempotent
const processedOrders = new Set();

app.post("/webhooks/orders", async (req, res) => {
  const order = req.body.data;

  // Check if already processed
  if (processedOrders.has(order.id)) {
    console.log(`Order ${order.id} already processed`);
    return res.status(200).send("Already processed");
  }

  try {
    await processOrder(order);
    processedOrders.add(order.id);
    res.status(200).send("OK");
  } catch (error) {
    console.error("Processing failed:", error);
    res.status(500).send("Error");
  }
});
```

### Monitoring and Logging

```javascript
// Add comprehensive logging and monitoring
class WorkflowMonitor {
  static logEvent(event, data) {
    console.log(
      JSON.stringify({
        timestamp: new Date().toISOString(),
        event,
        data,
        level: "info",
      }),
    );
  }

  static logError(event, error, data) {
    console.error(
      JSON.stringify({
        timestamp: new Date().toISOString(),
        event,
        error: error.message,
        stack: error.stack,
        data,
        level: "error",
      }),
    );
  }
}

// Usage throughout your workflow
WorkflowMonitor.logEvent("order_processing_started", { order_id: order.id });
WorkflowMonitor.logError("shipment_creation_failed", error, {
  order_id: order.id,
});
```

## What's Next?

- [Webhooks →](/docs/products/webhooks) - Complete webhook implementation guide
- [API Reference →](/docs/reference/rest) - Full REST API documentation
- [Batch Processing →](/docs/products/batch-processing) - Bulk operations and efficiency
- [Events →](/docs/products/events) - Event-driven architecture patterns
